# Task: Fix Pipeline Runs ID Field Naming

Resolve the `id` vs `run_id` ambiguity in the pipeline runs implementation across backend and frontend.

-----

## Problem

The `PipelineRunSummary` model uses `id: str` for the UUID, but:

- `id` typically means database row ID (integer)
- `run_id` is the convention for UUID business identifier (used in all other tables)
- Frontend type inference is breaking due to ambiguity

-----

## Part 1: Backend Changes

### Step 1: Update Database Table

Modify `pipeline_runs` table to follow the same pattern as other tables:

```sql
CREATE TABLE pipeline_runs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Row ID (consistent with other tables)
    run_id TEXT NOT NULL UNIQUE,           -- UUID business identifier
    status TEXT NOT NULL DEFAULT 'running',
    started_at TEXT NOT NULL,
    completed_at TEXT,
    error_message TEXT,
    normalization_count INTEGER,
    resolution_count INTEGER,
    survivorship_count INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_pipeline_runs_run_id ON pipeline_runs(run_id);
CREATE INDEX IF NOT EXISTS idx_pipeline_runs_status ON pipeline_runs(status);
```

### Step 2: Update Pydantic Schemas

**API schemas** - Use `run_id`, don’t expose database `id`:

```python
class PipelineRunSummary(BaseModel):
    """Summary of a pipeline run for list view."""
    
    run_id: str = Field(description="Unique run identifier (UUID)")
    status: PipelineRunStatus = Field(description="Current status")
    started_at: datetime = Field(description="When the run started")
    completed_at: datetime | None = Field(default=None)
    normalization_count: int | None = Field(default=None)
    resolution_count: int | None = Field(default=None)
    survivorship_count: int | None = Field(default=None)


class PipelineRunDetail(PipelineRunSummary):
    """Detailed pipeline run info."""
    
    error_message: str | None = Field(default=None)
    created_at: datetime = Field(description="Record creation timestamp")
```

**Note:** No `id` field in API schemas. Frontend uses `run_id` for everything.

### Step 3: Update Service Layer

Update the row-to-model conversion:

```python
def _row_to_summary(self, row: sqlite3.Row) -> PipelineRunSummary:
    return PipelineRunSummary(
        run_id=row["run_id"],  # Changed from row["id"]
        status=PipelineRunStatus(row["status"]),
        started_at=datetime.fromisoformat(row["started_at"]),
        completed_at=datetime.fromisoformat(row["completed_at"]) if row["completed_at"] else None,
        normalization_count=row["normalization_count"],
        resolution_count=row["resolution_count"],
        survivorship_count=row["survivorship_count"],
    )
```

Update any methods that reference `id` to use `run_id`:

```python
def get_run(self, run_id: str) -> PipelineRunDetail | None:
    """Get a single run by run_id."""
    cursor = conn.execute(
        "SELECT * FROM pipeline_runs WHERE run_id = ?",  # Changed from id = ?
        (run_id,),
    )
    ...

def create_run(self, run_id: str) -> PipelineRunDetail:
    """Create a new pipeline run record."""
    conn.execute(
        """
        INSERT INTO pipeline_runs (run_id, status, started_at)
        VALUES (?, 'running', ?)
        """,
        (run_id, now),
    )
    ...
```

### Step 4: Update API Endpoints

Ensure path parameter is `run_id`:

```python
@router.get(
    "/runs/{run_id}",
    response_model=PipelineRunDetail,
)
async def get_pipeline_run(run_id: str) -> PipelineRunDetail:
    run = runs_service.get_run(run_id)
    if not run:
        raise HTTPException(status_code=404, detail="Pipeline run not found")
    return run
```

### Step 5: Migrate Existing Data (If Applicable)

If table already exists with `id TEXT PRIMARY KEY`:

```sql
-- Create new table with correct schema
CREATE TABLE pipeline_runs_new (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    run_id TEXT NOT NULL UNIQUE,
    status TEXT NOT NULL,
    started_at TEXT NOT NULL,
    completed_at TEXT,
    error_message TEXT,
    normalization_count INTEGER,
    resolution_count INTEGER,
    survivorship_count INTEGER,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Migrate data (old 'id' becomes 'run_id')
INSERT INTO pipeline_runs_new (run_id, status, started_at, completed_at, error_message, normalization_count, resolution_count, survivorship_count, created_at)
SELECT id, status, started_at, completed_at, error_message, normalization_count, resolution_count, survivorship_count, created_at
FROM pipeline_runs;

-- Swap tables
DROP TABLE pipeline_runs;
ALTER TABLE pipeline_runs_new RENAME TO pipeline_runs;

-- Recreate indexes
CREATE INDEX idx_pipeline_runs_run_id ON pipeline_runs(run_id);
CREATE INDEX idx_pipeline_runs_status ON pipeline_runs(status);
```

### Step 6: Verify Backend

```bash
# Start server
uvicorn main:app --reload

# Test list endpoint
curl "http://localhost:8000/api/v1/pipeline/runs" | jq '.items[0]'
# Should show: { "run_id": "uuid-here", "status": "...", ... }
# Should NOT have "id" field

# Test detail endpoint  
curl "http://localhost:8000/api/v1/pipeline/runs/{run_id}" | jq
# Should show: { "run_id": "uuid-here", ... }
```

-----

## Part 2: Frontend Changes

### Step 1: Regenerate Types

```bash
npm run generate:api
```

### Step 2: Verify Generated Types

Check `src/shared/api/schema.generated.ts`:

```typescript
// Should now show:
PipelineRunSummary: {
    run_id: string;    // NOT id: string
    status: "running" | "completed" | "failed";
    started_at: string;
    // ...
}
```

### Step 3: Update Type Aliases

```typescript
// src/shared/api/types.ts
export type PipelineRunSummary = components["schemas"]["PipelineRunSummary"];
export type PipelineRunDetail = components["schemas"]["PipelineRunDetail"];
// No changes needed if using generated types directly
```

### Step 4: Update Components

Find and replace any references to `run.id` with `run.run_id`:

**Pipeline runs table/list:**

```typescript
// Column definition
{
    accessorKey: "run_id",  // Changed from "id"
    header: "Run ID",
}

// Row click handler
const handleRowClick = (run: PipelineRunSummary) => {
    navigate(`/pipeline/runs/${run.run_id}`);  // Changed from run.id
};

// Key prop in lists
{runs.map(run => (
    <Row key={run.run_id} ... />  // Changed from run.id
))}
```

**Query hooks:**

```typescript
// Query key should use run_id
queryKey: ["pipeline-run", runId],  // runId is the UUID string

// Any lookups
const run = runs.find(r => r.run_id === selectedRunId);
```

### Step 5: Remove Type Workarounds

Remove any type assertions or workarounds that were added to handle the ambiguity:

```typescript
// ❌ Remove this kind of code:
const runs = data.items.map(run => ({
    ...run,
    id: Number(run.id),
})) as PipelineRunWithNumericId[];

// ✅ Replace with direct usage:
const runs = data?.items ?? [];
```

### Step 6: Verify Frontend

```bash
npm run typecheck   # Should pass with no errors
npm run lint        # Should pass
npm run dev         # Test in browser
```

Test:

- [ ] Runs list loads
- [ ] Run ID displays correctly (UUID string)
- [ ] Clicking row navigates to correct URL
- [ ] Detail page loads with correct run

-----

## Naming Convention (Reference)

|Field   |Type    |Meaning                         |Used In                              |
|--------|--------|--------------------------------|-------------------------------------|
|`id`    |`number`|Database row ID (auto-increment)|Database only, not exposed to API    |
|`run_id`|`string`|UUID business identifier        |API, frontend, cross-table references|

This convention applies to all tables:

- `normalization_results`: `id` (row), `run_id` (UUID)
- `resolution_results`: `id` (row), `run_id` (UUID)
- `survivorship_results`: `id` (row), `run_id` (UUID)
- `pipeline_runs`: `id` (row), `run_id` (UUID)
- `os_catalog`: `id` (row), `os_id` (business ID)
- `alias_lookup`: `id` (row), `os_id` (foreign key)

-----

## Checklist

### Backend

- [ ] Table schema updated (id INTEGER, run_id TEXT)
- [ ] Pydantic schemas use `run_id`, not `id`
- [ ] Service layer queries by `run_id`
- [ ] Endpoints use `run_id` path parameter
- [ ] Existing data migrated (if applicable)
- [ ] API returns `run_id` field, not `id`
- [ ] `ruff check --fix && ruff format`
- [ ] `mypy` clean

### Frontend

- [ ] Types regenerated from OpenAPI
- [ ] Generated types show `run_id: string`
- [ ] Components updated to use `run_id`
- [ ] Type assertions/workarounds removed
- [ ] `npm run typecheck` clean
- [ ] `npm run lint` clean
- [ ] Navigation works correctly
- [ ] No runtime errors

-----

## Do Not

- Keep `id` in API schema as the UUID - rename to `run_id`
- Use type assertions to force incorrect types
- Have both `id` and `run_id` meaning UUID in different places
- Skip regenerating frontend types after backend changes